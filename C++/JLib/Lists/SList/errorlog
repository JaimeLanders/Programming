In file included from main.cpp:6:0:
slist.h: In instantiation of ‘SList<T>::SList() [with T = int]’:
main.cpp:28:16:   required from here
slist.h:61:17: error: call of overloaded ‘Ptr()’ is ambiguous
 SList<T>::SList()
                 ^
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:18:14: note: candidate: Ptr<T>::Ptr(T*) [with T = SList<int>::Node]
     explicit Ptr(T *p = nullptr){ ptr = p; };   // Copy constructor
              ^~~
../../Ptr/ptr.h:17:5: note: candidate: Ptr<T>::Ptr() [with T = SList<int>::Node]
     Ptr(){ ptr = nullptr; };                    // Default constructor
     ^~~
In file included from main.cpp:6:0:
slist.h: In instantiation of ‘SList<T>::~SList() [with T = int]’:
main.cpp:28:16:   required from here
slist.h:132:11: error: cannot convert ‘SList<int>::head’ from type ‘Ptr<SList<int>::Node> (SList<int>::)(SList<int>::Node (*)())’ to type ‘SList<int>::Node*’
     Node *it = head;
           ^~
slist.h:133:11: error: cannot convert ‘SList<int>::head’ from type ‘Ptr<SList<int>::Node> (SList<int>::)(SList<int>::Node (*)())’ to type ‘SList<int>::Node*’
     Node *temp = head;
           ^~~~
slist.h:137:14: error: cannot convert ‘Ptr<SList<int>::Node>’ to ‘SList<int>::Node*’ in assignment
         temp = it->next;
         ~~~~~^~~~~~~~~~
slist.h:138:18: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<int>::Node>’ and ‘std::nullptr_t’)
         it->next = nullptr;
         ~~~~~~~~~^~~~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<int>::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘SList<int>::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<int>::Node>& Ptr<SList<int>::Node>::operator=(const Ptr<SList<int>::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘const Ptr<SList<int>::Node>&’
In file included from main.cpp:6:0:
slist.h:143:10: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = int]’ (did you forget the ‘()’ ?)
     head = nullptr;
     ~~~~~^~~~~~~~~
slist.h: In instantiation of ‘SList<T>::SList() [with T = char*]’:
main.cpp:29:18:   required from here
slist.h:61:17: error: call of overloaded ‘Ptr()’ is ambiguous
 SList<T>::SList()
                 ^
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:18:14: note: candidate: Ptr<T>::Ptr(T*) [with T = SList<char*>::Node]
     explicit Ptr(T *p = nullptr){ ptr = p; };   // Copy constructor
              ^~~
../../Ptr/ptr.h:17:5: note: candidate: Ptr<T>::Ptr() [with T = SList<char*>::Node]
     Ptr(){ ptr = nullptr; };                    // Default constructor
     ^~~
In file included from main.cpp:6:0:
slist.h: In instantiation of ‘SList<T>::~SList() [with T = char*]’:
main.cpp:29:18:   required from here
slist.h:132:11: error: cannot convert ‘SList<char*>::head’ from type ‘Ptr<SList<char*>::Node> (SList<char*>::)(SList<char*>::Node (*)())’ to type ‘SList<char*>::Node*’
     Node *it = head;
           ^~
slist.h:133:11: error: cannot convert ‘SList<char*>::head’ from type ‘Ptr<SList<char*>::Node> (SList<char*>::)(SList<char*>::Node (*)())’ to type ‘SList<char*>::Node*’
     Node *temp = head;
           ^~~~
slist.h:137:14: error: cannot convert ‘Ptr<SList<char*>::Node>’ to ‘SList<char*>::Node*’ in assignment
         temp = it->next;
         ~~~~~^~~~~~~~~~
slist.h:138:18: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<char*>::Node>’ and ‘std::nullptr_t’)
         it->next = nullptr;
         ~~~~~~~~~^~~~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<char*>::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘SList<char*>::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<char*>::Node>& Ptr<SList<char*>::Node>::operator=(const Ptr<SList<char*>::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘const Ptr<SList<char*>::Node>&’
In file included from main.cpp:6:0:
slist.h:143:10: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = char*]’ (did you forget the ‘()’ ?)
     head = nullptr;
     ~~~~~^~~~~~~~~
slist.h: In instantiation of ‘SList<T>::SList() [with T = Data<int>]’:
main.cpp:30:22:   required from here
slist.h:61:17: error: call of overloaded ‘Ptr()’ is ambiguous
 SList<T>::SList()
                 ^
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:18:14: note: candidate: Ptr<T>::Ptr(T*) [with T = SList<Data<int> >::Node]
     explicit Ptr(T *p = nullptr){ ptr = p; };   // Copy constructor
              ^~~
../../Ptr/ptr.h:17:5: note: candidate: Ptr<T>::Ptr() [with T = SList<Data<int> >::Node]
     Ptr(){ ptr = nullptr; };                    // Default constructor
     ^~~
In file included from main.cpp:6:0:
slist.h: In instantiation of ‘SList<T>::~SList() [with T = Data<int>]’:
main.cpp:30:22:   required from here
slist.h:132:11: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
     Node *it = head;
           ^~
slist.h:133:11: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
     Node *temp = head;
           ^~~~
slist.h:137:14: error: cannot convert ‘Ptr<SList<Data<int> >::Node>’ to ‘SList<Data<int> >::Node*’ in assignment
         temp = it->next;
         ~~~~~^~~~~~~~~~
slist.h:138:18: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘std::nullptr_t’)
         it->next = nullptr;
         ~~~~~~~~~^~~~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:143:10: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’ (did you forget the ‘()’ ?)
     head = nullptr;
     ~~~~~^~~~~~~~~
slist.h: In instantiation of ‘void SList<T>::insert(T) [with T = Data<int>]’:
main.cpp:118:23:   required from here
slist.h:194:14: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’ (did you forget the ‘()’ ?)
     if (head == nullptr) // Case 1: list empty
         ~~~~~^~~~~~~~~~
slist.h:199:14: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’ (did you forget the ‘()’ ?)
         head = nNode;
         ~~~~~^~~~~~~
slist.h:200:14: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘SList<Data<int> >::Node*’)
         tail = nNode;
         ~~~~~^~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:209:17: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’ (did you forget the ‘()’ ?)
         if (n < head->data) // Case 2A : n is new head
                 ^~~~
slist.h:209:17: error: base operand of ‘->’ is not a pointer
slist.h:214:25: error: invalid use of non-static member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’
             nNode->next = head;
             ~~~~~~~~~~~~^~~~~~
slist.h:38:15: note: declared here
     Ptr<Node> head(Node()); // Needs work
               ^~~~
slist.h:216:18: error: invalid use of member function ‘Ptr<SList<T>::Node> SList<T>::head(SList<T>::Node (*)()) [with T = Data<int>]’ (did you forget the ‘()’ ?)
             head = nNode;
             ~~~~~^~~~~~~
slist.h:223:20: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
             Node * it = head;
                    ^~
slist.h:224:20: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
             Node * prev  = head;
                    ^~~~
slist.h:226:29: error: no match for ‘operator!=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘std::nullptr_t’)
             while (it->next != nullptr)
                    ~~~~~~~~~^~~~~~~~~~
slist.h:236:33: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘SList<Data<int> >::Node*’)
                     nNode->next = it;
                     ~~~~~~~~~~~~^~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:237:32: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘SList<Data<int> >::Node*’)
                     prev->next = nNode;
                     ~~~~~~~~~~~^~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:246:26: error: invalid cast from type ‘Ptr<SList<Data<int> >::Node>’ to type ‘SList<Data<int> >::Node*’
                     it = (Node*)it->next;
                          ^~~~~~~~~~~~~~~
slist.h:250:26: error: no match for ‘operator==’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘std::nullptr_t’)
             if (it->next == nullptr)
                 ~~~~~~~~~^~~~~~~~~~
slist.h:255:26: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘SList<Data<int> >::Node*’)
                 it->next = nNode;
                 ~~~~~~~~~^~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:256:32: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘std::nullptr_t’)
                 it->next->next = nullptr;
                 ~~~~~~~~~~~~~~~^~~~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h:257:22: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘SList<Data<int> >::Node*’)
                 tail = nNode;
                 ~~~~~^~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘SList<Data<int> >::Node*’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:6:0:
slist.h: In instantiation of ‘void SList<T>::print() [with T = Data<int>]’:
main.cpp:122:17:   required from here
slist.h:371:12: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
     Node * it = head;
            ^~
slist.h:376:14: error: invalid cast from type ‘Ptr<SList<Data<int> >::Node>’ to type ‘SList<Data<int> >::Node*’
         it = (Node*)it->next;
              ^~~~~~~~~~~~~~~
slist.h: In instantiation of ‘bool SList<T>::search(T) [with T = Data<int>]’:
main.cpp:125:27:   required from here
slist.h:497:17: error: cannot convert ‘SList<Data<int> >::head’ from type ‘Ptr<SList<Data<int> >::Node> (SList<Data<int> >::)(SList<Data<int> >::Node (*)())’ to type ‘SList<Data<int> >::Node*’
     for (Node * it = head; it != nullptr; it = (Node*)it->next)
                 ^~
slist.h:497:48: error: invalid cast from type ‘Ptr<SList<Data<int> >::Node>’ to type ‘SList<Data<int> >::Node*’
     for (Node * it = head; it != nullptr; it = (Node*)it->next)
                                                ^~~~~~~~~~~~~~~
slist.h: In instantiation of ‘SList<T>::Node::Node() [with T = Data<int>]’:
slist.h:190:20:   required from ‘void SList<T>::insert(T) [with T = Data<int>]’
main.cpp:118:23:   required from here
slist.h:32:15: error: call of overloaded ‘Ptr()’ is ambiguous
         Node(){next = nullptr;};
               ^
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:18:14: note: candidate: Ptr<T>::Ptr(T*) [with T = SList<Data<int> >::Node]
     explicit Ptr(T *p = nullptr){ ptr = p; };   // Copy constructor
              ^~~
../../Ptr/ptr.h:17:5: note: candidate: Ptr<T>::Ptr() [with T = SList<Data<int> >::Node]
     Ptr(){ ptr = nullptr; };                    // Default constructor
     ^~~
In file included from main.cpp:6:0:
slist.h:32:21: error: no match for ‘operator=’ (operand types are ‘Ptr<SList<Data<int> >::Node>’ and ‘std::nullptr_t’)
         Node(){next = nullptr;};
                ~~~~~^~~~~~~~~
In file included from slist.h:12:0,
                 from main.cpp:6:
../../Ptr/ptr.h:24:8: note: candidate: T* Ptr<T>::operator=(T) [with T = SList<Data<int> >::Node]
     T* operator = (T n){ *ptr = n; };           // Works but synax not consistent with raw pointer
        ^~~~~~~~
../../Ptr/ptr.h:24:8: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘SList<Data<int> >::Node’
../../Ptr/ptr.h:12:7: note: candidate: constexpr Ptr<SList<Data<int> >::Node>& Ptr<SList<Data<int> >::Node>::operator=(const Ptr<SList<Data<int> >::Node>&)
 class Ptr
       ^~~
../../Ptr/ptr.h:12:7: note:   no known conversion for argument 1 from ‘std::nullptr_t’ to ‘const Ptr<SList<Data<int> >::Node>&’
In file included from main.cpp:8:0:
../../Data/data.h:34:17: warning: inline function ‘bool operator<(const Data<int>&, const Data<int>&)’ used but never defined
     friend bool operator < (const Data<T>& d1, const Data<T>& d2)
                 ^~~~~~~~
../../Data/data.h:27:17: warning: inline function ‘bool operator==(const Data<int>&, const Data<int>&)’ used but never defined
     friend bool operator == (const Data<T>& d1, const Data<T>& d2)
                 ^~~~~~~~
